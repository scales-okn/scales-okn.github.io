import{_ as s,M as i,p as c,q as d,R as e,N as a,V as l,t,a1 as n}from"./framework-5866ffd3.js";const h={},p=e("h1",{id:"pacer-redaction-script",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#pacer-redaction-script","aria-hidden":"true"},"#"),t(" PACER redaction script")],-1),u={style:{"margin-top":"-0.5em"}},f=e("em",null,"by Scott Daniel â€¢ last updated Jan 9, 2024",-1),m=n(`<p>This script is a wrapper for the function <code>redact_private_individual_names()</code> in <code>support/data_tools.py</code>. That function takes a text representation of a PACER case, i.e. either raw HTML or a SCALES-parsed JSON dict, and returns the same text with the names of private individuals (see &quot;Notes on approach&quot; for an explanation of how we defined this category) replaced with anonymized hash strings. <code>redact_pacer.py</code> simply applies <code>redact_private_individual_names</code> to a list of files, and writes the results to a new directory; the input and output directories are currently hardcoded to reflect the structure of SCALES&#39;s internal datastore.</p><h2 id="usage" tabindex="-1"><a class="header-anchor" href="#usage" aria-hidden="true">#</a> Usage</h2><p><code>python redact_pacer.py file_pattern outdir_replacement_target outdir_replacement_text</code></p><p><code>file_pattern</code> should be a glob pattern describing all the files to be redacted; for instance, to redact all the HTML/JSON files in a folder called <code>pacer</code> conforming to the SCALES scraper/parser file structure, pass <code>pacer/*/[hj]*/*/*.[hj]*</code> (the &#39;h&#39; and &#39;j&#39; are meant to match &#39;html&#39; and &#39;json&#39;).</p><p><code>outdir_replacement_target</code> and <code>outdir_replacement_text</code> provide a convenient way to specify an output path for each file: for a file with the path <code>inpath</code>, the redacted version of that file will be written to the path <code>inpath.replace(outdir_replacement_target, outdir_replacement_text)</code>, and all intermediate directories will be created if they do not yet exist. For esaxmple, to create an output folder called <code>pacer_redacted</code> in which to write the redacted versions of files in the <code>pacer</code> folder, pass <code>pacer</code> and <code>pacer_redacted</code>; in that case, for a file with path <code>pacer/akd/html/00/1:00-cv-00001.html</code>, the redacted version would be written to path <code>pacer_redacted/akd/html/00/1:00-cv-00001.html</code>.</p><p>This script is also included in the <code>pacer_tools</code> package, where it can be called as follows:</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> pacer_tools<span class="token punctuation">.</span>code<span class="token punctuation">.</span>tasks <span class="token keyword">import</span> redact_pacer
redact_pacer<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;in/*.html&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;in/&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;out/&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> standalone_mode<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>(Another option is to import <code>data_tools</code> from <code>pacer_tools.code.support</code> and call <code>data_tools.redact_private_individual_names()</code> directly.)</p><h2 id="why-is-this-needed" tabindex="-1"><a class="header-anchor" href="#why-is-this-needed" aria-hidden="true">#</a> Why is this needed?</h2>`,9),g={href:"https://satyrn.scales-okn.org/",target:"_blank",rel:"noopener noreferrer"},y={href:"http://scalesokndata.ci.northwestern.edu/",target:"_blank",rel:"noopener noreferrer"},w=n('<h2 id="notes-on-approach" tabindex="-1"><a class="header-anchor" href="#notes-on-approach" aria-hidden="true">#</a> Notes on approach</h2><p>The process of redacting names begins with a call to <code>support/party_classification.py</code> to determine which parties on the case are private individuals, continues with a call to <code>support/party_tagging.py</code> to identify text spans that include those parties&#39; names, and concludes with code that performs the redaction itself by replacing those spans with hash strings. We settled on this piecemeal solution to the problem because it was a relatively quick-to-implement choice (time was of the essence given our fall &#39;23 public launch of the Satyrn platform) and because it utilized portions of our large pre-existing codebase rather than starting from scratch on tasks like party classification and intra-case span tagging.</p><p>We also tried to account for the eccentricities of PACER data in our approach to the redaction task. For instance, although the set of all unique party names in our PACER dataset reveals a remarkable variety of entity types and text patterns, most of the hardest-to-interpret phenomena (complex chains of &quot;X as representative of Y,&quot; names with missing or garbled text, single words with no other clarifying information, and so on) belong to a long tail of low-frequency party names that together comprise only a small portion of all parties. Thus, when classifying parties, we felt secure in using a conceptually simple lexicon-based approach, knowing that such an approach could reliably mop up the non-long-tail part of the distribution that contains the vast majority of PACER parties.</p><p>Finally, what sets apart &quot;private individuals&quot; from other parties? In other words, whose privacy needs to be protected via the redaction process? We define a private individual as a person who is involved in a court case in a non-professional capacity; that is, (1) they are a single human rather than a company, organization, government, group of people, etc, and (2) their participation in the litigation is not contingent on their status as a public official, police officer, doctor, lawyer, chairperson, owner of an asset, representative of a company or an estate, etc. (For more information, see the <code>name_redaction_tree()</code> decision-tree function in <code>party_classification.py</code>, which contains the rules that demarcate this category in practice.) With this definition, we believe we are drawing a balanced distinction between people involved in the legal system due to the circumstances of their private lives on the one hand, and people &amp; organizations knowingly engaging in legal activity pertinent to the public on the other. That said, in truly gray-area situations, we have tried to make the &quot;private individual&quot; category over-inclusive and err on the side of over-redaction, under the assumption that the harm of leaving a true private individual&#39;s name exposed would be greater than the harm of erroneously concealing the name of a non-private-individual party.</p><h2 id="known-issues" tabindex="-1"><a class="header-anchor" href="#known-issues" aria-hidden="true">#</a> Known issues</h2><h3 id="technical" tabindex="-1"><a class="header-anchor" href="#technical" aria-hidden="true">#</a> Technical</h3><ul><li><code>redact_pacer.py</code> currently does not use multiprocessing, and would probably run a lot faster if it did. (We made a quick attempt at parallelization using <code>joblib</code>, but this ended up slowing the script down immensely.)</li><li>For speed reasons, fuzzy matching had to be removed from <code>party_tagging.py</code>.</li><li>A few cases (i.e. cases with over 1000 parties slated for redaction) raised the <code>is_huge_case</code> flag and thus were redacted without applying the anchor-tagging strategy (i.e. with exact-match tagging only), due to the extra few hours of runtime per case that anchor tagging would have entailed. If the anchor tagger can be optimized (or if <code>redact_pacer.py</code> is parallelized, or if future phases of work on this problem can accommodate very long runtimes), those cases should be rerun.</li><li>Due to a shortcut taken when generating <code>party_chunks</code> (in order to avoid the awkward <code>split_on_multiple_separators</code> method used by the PACER parser), party hashes in HTML files often differ from those in the corresponding JSONs.</li><li>The &quot;hash1 or hash2&quot; notation used for redaction of ambiguous parties in the docket table has not been implemented for redaction of the case title.</li><li>The assumption that party names in the case title will take the form <code>party_name.split()[-1]</code> is not always correct; for instance, in a random sample of 10,000 cases, 16 included names whose final token was an item in lexicon.person_words (e.g. &quot;Joe Smith Jr&quot;).</li><li>The case-title redaction heuristic is based on the PACER parser&#39;s conservative approach to finding the case title within the HTML file, and thus misses some fairly obvious appearances of party names in the handful of cases with non-standard case titles (see e.g. utd;;1:16-cv-00101).</li><li>Pro-se parties are currently identified by a check for the text &quot;PRO SE,&quot; a PACER flag that is present alongside almost all pro-se parties. However, the function <code>pro_se_identifier()</code> (in <code>support/text_functions.py</code>) is a more robust solution to the problem of pro-se identification, and could be used in <code>redact_private_individual_names()</code> instead of the current naive check.</li><li>The portions of <code>redact_private_individual_names()</code> that split HTML data into its constituent parts (1) may be duplicative given the HTML-parsing code already present in <code>parsers/parse_pacer.py</code> and (2) might be performing redundant computations in situations in which the HTML files in question have already been parsed into JSON files residing elsewhere.</li><li>Some of the <code>break</code> statements in <code>_apply_second_order_labeling_procedures()</code> may be ending their respective loops before all of the necessary label adjustments have been completed (this could be fixed by rewriting them as list comprehensions).</li><li>Lines involving the variable <code>first_ei_word</code> should be rewritten to allow checks for multi-word phrases at the beginning of the extra info. This is not currently a problem in <code>name_redaction_multient_handler()</code>, but it is a problem in <code>_handle_multi_entities()</code>, the generic handler (unused in <code>redact_private_individual_names()</code>) left over from the era in which <code>party_classification.py</code> was used for more than just redaction.</li><li>The regexes used in the multi-entity-handling code currently match some phrases (like &quot;individual capacity&quot;) that were relevant in earlier eras of fine-grained party splitting/detection but that may be a hindrance in the simpler context of private-individual detection.</li><li>The <code>synecdoche_nonperson_superseding</code> word list, which was designed to solve certain as-yet-unsolved problems relating to multi-entity classification (see the associated comment in <code>lexicon.py</code>), is not currently being used.</li><li>No checks have been performed to detect collisions between hash abbreviations within individual cases, or between long hashes across the whole dataset (although such collisions are exceedingly unlikely).</li></ul><h3 id="conceptual" tabindex="-1"><a class="header-anchor" href="#conceptual" aria-hidden="true">#</a> Conceptual</h3><ul><li>At present, the party-tagging algorithm may produce false positives when multiple party names share tokens (e.g. when &quot;Alice Smith&quot; needs to be redacted, &quot;Officer Bob Smith&quot; may erroneously be redacted as well) or when name tokens can double as non-name tokens (e.g. when &quot;Jude Law&quot; needs to be redacted, the word &quot;law&quot; may erroneously be redacted wherever it appears). Inspecting the set of all unique party names may reveal further problems of this sort. (Note that false positives exacerbate this problem; for example, in the rare case of a party ending in &quot;Company&quot; being flagged for redaction, as in ilnd;;3:21-cv-50125, the word &quot;company&quot; may erroneously be redacted elsewhere as well.)</li><li>The <code>human_affixes</code> list we inherited as part of <code>party_tagging.py</code> is quite limited, and future versions could benefit from expanding it, perhaps by pulling in some keywords from <code>support/lexicon.py</code>.</li><li>The distinction between <code>person_words</code> (associated with private individuals) and <code>professional_words</code> (associated with non-private individuals) is currently rather blurry. For instance, can we presume that people listed with honorifics like &quot;Dr,&quot; &quot;MD,&quot; &quot;PhD,&quot; and &quot;RN&quot; are participating in their cases in their professional capacities, or should we allow for the possibility that these people are involved in the litigation no differently than those listed as &quot;Mr,&quot; &quot;Mrs,&quot; and so on?</li><li>The <code>as_x_of_y</code> regex was originally designed for multi-entity detection in the context of fine-grained party classification; now that the multi-entity-detection parts of this code are essentially a proxy for the detection of all non-private entities, it could be worthwhile to expand that regex to match the broader pattern &quot;X of Y.&quot;</li><li>Some of the rules in <code>name_redaction_tree()</code> depend on context-specific information like a case&#39;s nature of suit, but in an ideal world, the party-classification process would be as context-independent as possible.</li><li>Among the handful of parties whose names have already been redacted (to e.g. &quot;John Doe&quot; or &quot;FNU LNU&quot;), which the redaction code currently passes over, some are occasionally followed by extra info that contains their real name (e.g. &quot;also known as Joe Smith,&quot; meaning that these parties should be redacted after all. (See e.g. ilnd;;1:12-cr-00624.)</li><li>The distinction between party names like &quot;Social Security Commissioner Carolyn Colvin&quot; (which would not be redacted) and &quot;Carolyn Colvin&quot; (which would be classified as a private individual and redacted), although reasonable on a programmatic level, is rather absurd on a conceptual level.</li><li>About 500 parties have extra-info blocks containing address information, which may include words that erroneously flag them as non-private entities.</li><li>Arguably, if city/state information were to be preserved in its unredacted form in address lines (both in pro-se blocks and extra-info blocks), research opportunities would increase without compromising privacy.</li><li>The presumption that individuals appearing in court on behalf of other people or entities are not private individuals may break down in the context of estate-settlement cases, in which, for instance, individuals named as beneficiaries or representatives may have been pulled into litigation without any deliberate action on their part.</li></ul>',9);function b(v,_){const r=i("font"),o=i("ExternalLinkIcon");return c(),d("div",null,[p,e("div",u,[a(r,{size:"2"},{default:l(()=>[f]),_:1})]),m,e("p",null,[t("At SCALES, facilitating access to legal data is our primary goal, but we also strive to weigh the benefits of a given increase in accessibility against the attendant risks. In the case of court records, greater access means greater opportunities for research, journalism, and judicial transparency, but also greater risk of abuse by, say, scammers hoping to leverage information about a person's history in the courts to intimidate or embarrass them, or employers attempting to discriminate against formerly incarcerated people. Fortunately, upon replacing each instance of a certain person's name in a PACER docket with a hash string specific to that person, these privacy concerns mostly disappear while the docket still retains its value in the context of aggregate research. This is the strategy we used to anonymize our own collection of PACER data (as it appears both in the "),e("a",g,[t("Satyrn app"),a(o)]),t(" and the raw "),e("a",y,[t("data files"),a(o)]),t(" we've made available for public download), and we offer this redaction script as a way for you to anonymize your own data.")]),w])}const q=s(h,[["render",b],["__file","index.html.vue"]]);export{q as default};
